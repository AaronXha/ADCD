向上走优化点
初始方式
对每个谓词尝试去掉，看是否是有效的 dc 例如 有abcd这个 dc 那么就要 abc abd acd bcd 这四种情况
如果这四种情况都不满足设定值 说明 abcd 满足最小性 递归结束 否则，当前这个 dc 不是有效 dc 把其去除。
同时对其满足的子集 dc 进行同样操作
粗暴方式: 把其缺少一个谓词的情况都写出来，然后对每个情况遍历evidence set 看是否达到阈值大小e
优化1: 计算这个 dc 的每个谓词的影响的 evidence set 数量，和 MMCS 类似
如果说其中任意一个谓词影响的数量去除后，都不能达到设定闽值的大小，那么这肯定是一个有效的 dc，结束递归，
如果不是 例如 a 谓影响的元组对数量是 1 当前这条 dc abcd,影响的元组对数量为10，同时，我设定的最少满足的元组对数量为 9，那么去除 a 后，得到 bcd是一条有效dc 那么abcd就不是一条有效 dc 因此对 bcd进行同样的操作，同时把abcd删除
优化2:对我遍历的节点进行一个记录，例如我遍历到 abcd 这个谓词，同时我检测出来其已经被检测过，那么我直接把结果拿出来，不需要进行重复的计算